<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文献查询 - 文献综述生成工具</title>
    <link rel="stylesheet" href="search.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>文献查询</h1>
            <p>根据研究主题搜索相关文献</p>
        </header>
        
        <main>
            <section class="project-section">
                <h3>项目管理</h3>
                <div class="project-controls">
                    <div class="input-group">
                        <div id="current-project-display">当前项目：<span id="current-project-name">未选择</span></div>
                        <button id="save-project-btn">保存到项目</button>
                    </div>
                </div>
            </section>
            
            <section class="search-controls">
                <div class="api-key-section">
                    <label for="api-key">DeepSeek API Key:</label>
                    <input type="password" id="api-key" placeholder="请输入您的DeepSeek API Key">
                </div>
                <div class="api-key-section">
                    <label>搜索偏好：</label>
                    <div class="input-group">
                        <input type="number" id="pref-keyword-count" placeholder="关键词数量(默认6)" min="1" style="max-width: 200px;">
                        <input type="number" id="pref-max-per-keyword" placeholder="每关键词文献数(默认10)" min="1" max="19" style="max-width: 200px;">
                        <input type="number" id="pref-start-year" placeholder="起始年份(可选)" min="1900" style="max-width: 200px;">
                        <input type="number" id="pref-min-citations" placeholder="最低引用数(可选)" min="0" style="max-width: 200px;">
                    </div>
                </div>
                
                <div class="step-section">
                    <h3>综述主题输入</h3>
                    <div class="input-group">
                        <textarea id="topic-display" placeholder="例如：写一个和共享自动驾驶汽车以及mass系统相关的综述"></textarea>
                        <button id="extract-keywords-btn">分析关键词</button>
                    </div>
                </div>
                
                <div class="keywords-section" id="keywords-section" style="display: none;">
                    <h3>关键词列表（可编辑）</h3>
                    <div class="keywords-container" id="keywords-container"></div>
                    <button id="search-literature-btn">确认关键词并开始搜索</button>
                </div>
                
                <div class="search-progress" id="search-progress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="search-progress-fill"></div>
                    </div>
                    <p id="search-progress-text">准备开始搜索...</p>
                </div>
            </section>
            
            <!-- 移除按关键词分页结果，仅展示合并后的最终结果 -->
            
            <section class="final-results-section" id="final-results-section" style="display: none;">
                <h2>最终文献列表</h2>
                <div class="final-results-info">
                    <p>共找到 <span id="final-count">0</span> 篇不重复文献</p>
                </div>
                <div class="final-results-container" id="final-results-container">
                    <div class="empty-state">
                        <p>暂无文献</p>
                    </div>
                </div>
                <div class="results-actions" style="margin-top:10px;">
                    <button id="complete-abstracts-btn">一键补充摘要</button>
                    <button id="export-excel-btn">导出Excel</button>
                </div>
            </section>
        </main>
        
        <footer>
            <div class="footer-controls">
                <button id="back-btn">返回主页面</button>
                <button id="confirm-btn" disabled>确认完成</button>
            </div>
        </footer>
        
        <!-- Toast通知 -->
        <div id="toast" class="toast" style="display: none;">
            <div class="toast-content">
                <span class="toast-message" id="toast-message"></span>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM元素
            const currentProjectNameSpan = document.getElementById('current-project-name');
            const saveProjectBtn = document.getElementById('save-project-btn');
            const apiKeyInput = document.getElementById('api-key');
            const prefKeywordCountInput = document.getElementById('pref-keyword-count');
            const prefMaxPerKeywordInput = document.getElementById('pref-max-per-keyword');
            const prefStartYearInput = document.getElementById('pref-start-year');
            const prefMinCitationsInput = document.getElementById('pref-min-citations');
            const topicDisplay = document.getElementById('topic-display');
            const extractKeywordsBtn = document.getElementById('extract-keywords-btn');
            const keywordsSection = document.getElementById('keywords-section');
            const keywordsContainer = document.getElementById('keywords-container');
            const searchLiteratureBtn = document.getElementById('search-literature-btn');
            const searchProgress = document.getElementById('search-progress');
            const searchProgressFill = document.getElementById('search-progress-fill');
            const searchProgressText = document.getElementById('search-progress-text');
            // 已移除分关键词结果展示
            const finalResultsSection = document.getElementById('final-results-section');
            const finalResultsContainer = document.getElementById('final-results-container');
            const finalCount = document.getElementById('final-count');
            const confirmBtn = document.getElementById('confirm-btn');
            const backBtn = document.getElementById('back-btn');
            const completeAbstractsBtn = document.getElementById('complete-abstracts-btn');
            // 分页与选择控件已移除
            
            // 数据存储
            let currentProject = null;
            let keywords = [];
            let searchResults = {}; // 每个关键词的搜索结果
            let allLiterature = []; // 去重后的所有文献
            
            // 初始化当前项目信息并加载数据
            initCurrentProject();
            async function initCurrentProject() {
                if (!window.electronAPI) return;
                try {
                    const { success, currentProject: cp } = await window.electronAPI.getCurrentProject();
                    if (success && cp) {
                        currentProject = cp;
                        currentProjectNameSpan.textContent = cp;
                        // 加载项目数据
                        const result = await window.electronAPI.loadProjectData(cp);
                        if (result.success && result.data) {
                            loadProjectData(result.data);
                            // 加载项目简介到输入框（如果存在）
                            const projectDescription = result.data.projectDescription || result.data.reviewDescription || result.data.userNeeds || result.data.researchTopic || '';
                            if (topicDisplay && projectDescription) {
                                topicDisplay.value = projectDescription;
                            }
                        }
                    } else {
                        showToast('未选择项目，请在主页面先新建或打开项目', 'error');
                    }
                } catch (e) {
                    console.error('获取当前项目失败:', e);
                }
            }
            
            // 显示Toast通知
            function showToast(message, type = 'success') {
                const toast = document.getElementById('toast');
                const toastMessage = document.getElementById('toast-message');
                
                if (!toast || !toastMessage) return;
                
                // 设置消息
                toastMessage.textContent = message;
                
                // 根据类型设置样式
                if (type === 'success') {
                    toast.style.background = 'linear-gradient(135deg, var(--success-color) 0%, #059669 100%)';
                } else if (type === 'error') {
                    toast.style.background = 'linear-gradient(135deg, var(--error-color) 0%, #dc2626 100%)';
                }
                
                // 显示toast
                toast.style.display = 'block';
                toast.style.opacity = '0';
                
                // 触发动画
                setTimeout(() => {
                    toast.style.opacity = '1';
                }, 10);
                
                // 3秒后自动隐藏
                setTimeout(() => {
                    toast.style.opacity = '0';
                    setTimeout(() => {
                        toast.style.display = 'none';
                    }, 300);
                }, 3000);
            }
            
            // 保存项目（合并保存，避免覆盖旧字段）
            saveProjectBtn.addEventListener('click', async function() {
                const projectName = currentProject;
                if (!projectName) {
                    showToast('未绑定项目，请返回主页面选择项目', 'error');
                    return;
                }
                
                const projectData = getModule1Patch();
                if (window.electronAPI) {
                    try {
                        await mergeAndSave(projectName, projectData);
                        showToast(`项目 "${projectName}" 保存成功`);
                    } catch (error) {
                        console.error('保存项目失败:', error);
                        showToast('保存项目失败: ' + error.message, 'error');
                    }
                }
            });
            
            // 获取项目数据
            function getModule1Patch() {
                // 从输入框获取综述主题
                const projectDescription = (topicDisplay && topicDisplay.value) ? topicDisplay.value.trim() : '';
                
                return {
                    projectDescription: projectDescription,
                    config: {
                    apiKey: apiKeyInput.value,
                        searchPreferences: {
                            keywordCount: Number(prefKeywordCountInput.value) || 6,
                            maxPerKeyword: Number(prefMaxPerKeywordInput.value) || 10,
                            startYear: prefStartYearInput.value || '',
                            minCitations: prefMinCitationsInput.value ? Number(prefMinCitationsInput.value) : ''
                        }
                    },
                    keywords: keywords,
                    search: {
                        results: searchResults
                    },
                    finalResults: allLiterature, // 保存所有文献，无论摘要是否完整
                    timestamp: new Date().toISOString()
                };
            }

            // 深合并保存，避免覆盖旧字段
            async function mergeAndSave(projectName, patch) {
                const existing = await window.electronAPI.loadProjectData(projectName);
                const base = (existing && existing.success && existing.data) ? existing.data : {};
                const merged = deepMerge(base, patch || {});
                return await window.electronAPI.saveProjectData(projectName, merged);
            }

            function deepMerge(target, source) {
                if (!source || typeof source !== 'object') return target;
                const out = Array.isArray(target) ? [...target] : { ...target };
                Object.keys(source).forEach(key => {
                    const srcVal = source[key];
                    const tgtVal = out[key];
                    
                    // 特殊处理：search.results 每次都应该完全覆盖，而不是合并
                    if (key === 'search' && srcVal && typeof srcVal === 'object') {
                        // search 对象：保留其他字段，只覆盖 results
                        if (!out[key]) out[key] = {};
                        if (srcVal.results !== undefined) {
                            // 直接覆盖 results，不合并
                            out[key].results = srcVal.results;
                        }
                        // 合并 search 对象的其他字段（如果有）
                        Object.keys(srcVal).forEach(subKey => {
                            if (subKey !== 'results') {
                                out[key][subKey] = srcVal[subKey];
                            }
                        });
                    } else if (srcVal && typeof srcVal === 'object' && !Array.isArray(srcVal)) {
                        out[key] = deepMerge(tgtVal && typeof tgtVal === 'object' ? tgtVal : {}, srcVal);
                    } else {
                        out[key] = srcVal;
                    }
                });
                return out;
            }
            
            // 加载项目数据
            function loadProjectData(data) {
                // 加载项目简介到输入框
                const projectDescription = data.projectDescription || data.reviewDescription || data.userNeeds || data.researchTopic || '';
                if (topicDisplay && projectDescription) {
                    topicDisplay.value = projectDescription;
                }
                
                apiKeyInput.value = (data.config && data.config.apiKey) || data.apiKey || '';
                const prefs = (data.config && data.config.searchPreferences) || {};
                prefKeywordCountInput.value = prefs.keywordCount || '';
                prefMaxPerKeywordInput.value = prefs.maxPerKeyword || '';
                prefStartYearInput.value = prefs.startYear || '';
                prefMinCitationsInput.value = prefs.minCitations || '';
                keywords = data.keywords || [];
                searchResults = (data.search && data.search.results) || data.searchResults || {};
                allLiterature = data.finalResults || data.allLiterature || [];
                
                if (keywords.length > 0) {
                    displayKeywords();
                    keywordsSection.style.display = 'block';
                }
                
                // 已移除分关键词结果展示
                
                if (allLiterature.length > 0) {
                    finalResultsSection.style.display = 'block';
                    // 加载项目数据时，显示所有文献
                    displayFinalResults();
                }
                
                updateConfirmButton();
            }
            
            // 不再从主进程获取研究主题，改为从项目数据中读取
            
            // 提取关键词
            extractKeywordsBtn.addEventListener('click', async function() {
                // 从输入框获取综述主题
                const topic = (topicDisplay && topicDisplay.value) ? topicDisplay.value.trim() : '';
                const apiKey = apiKeyInput.value.trim();
                
                if (!apiKey) {
                    showToast('请输入DeepSeek API Key', 'error');
                    return;
                }
                
                if (!topic) {
                    showToast('请输入综述主题', 'error');
                    return;
                }
                
                try {
                    // 调用DeepSeek API提取关键词
                    const extractedKeywords = await extractKeywords(topic, apiKey);
                    const desiredCount = Number(prefKeywordCountInput.value) || 6;
                    keywords = extractedKeywords.slice(0, desiredCount);
                    displayKeywords();
                    keywordsSection.style.display = 'block';
                    // 参数生效：自动保存到项目
                    await autoSaveConfig();
                } catch (error) {
                    console.error('提取关键词失败:', error);
                    showToast('提取关键词失败: ' + error.message, 'error');
                }
            });
            
            // 显示关键词
            function displayKeywords() {
                keywordsContainer.innerHTML = '';
                keywords.forEach((keyword, index) => {
                    const keywordElement = document.createElement('div');
                    keywordElement.className = 'keyword-item';
                    keywordElement.innerHTML = `
                        <input type="text" class="keyword-input" value="${keyword}" data-index="${index}">
                        <button class="remove-keyword-btn" data-index="${index}">删除</button>
                    `;
                    keywordsContainer.appendChild(keywordElement);
                });
                
                // 添加新的关键词输入框
                const addKeywordElement = document.createElement('div');
                addKeywordElement.className = 'keyword-item';
                addKeywordElement.innerHTML = `
                    <input type="text" class="keyword-input new-keyword" placeholder="添加新关键词">
                    <button class="add-keyword-btn">添加</button>
                `;
                keywordsContainer.appendChild(addKeywordElement);
                
                // 绑定事件
                document.querySelectorAll('.keyword-input').forEach(input => {
                    input.addEventListener('blur', updateKeyword);
                });
                
                document.querySelectorAll('.remove-keyword-btn').forEach(btn => {
                    btn.addEventListener('click', removeKeyword);
                });
                
                document.querySelector('.add-keyword-btn').addEventListener('click', addKeyword);
            }
            
            // 更新关键词
            function updateKeyword(event) {
                const index = event.target.getAttribute('data-index');
                if (index !== null) {
                    keywords[parseInt(index)] = event.target.value;
                }
                // 保存关键词更改
                autoSaveConfig();
            }
            
            // 删除关键词
            function removeKeyword(event) {
                const index = parseInt(event.target.getAttribute('data-index'));
                keywords.splice(index, 1);
                displayKeywords();
                // 保存关键词更改
                autoSaveConfig();
            }
            
            // 添加关键词
            function addKeyword() {
                const newKeywordInput = document.querySelector('.new-keyword');
                const newKeyword = newKeywordInput.value.trim();
                if (newKeyword) {
                    keywords.push(newKeyword);
                    displayKeywords();
                    newKeywordInput.value = '';
                    // 保存关键词更改
                    autoSaveConfig();
                }
            }
            
            // 开始搜索文献
            searchLiteratureBtn.addEventListener('click', async function() {
                const apiKey = apiKeyInput.value.trim();
                
                if (!apiKey) {
                    showToast('请输入DeepSeek API Key', 'error');
                    return;
                }
                
                if (keywords.length === 0) {
                    showToast('请先提取或添加关键词', 'error');
                    return;
                }
                
                // 清空模块1的文献列表（开始新搜索前）
                console.log('清空模块1的文献列表，开始新搜索...');
                searchResults = {}; // 清空搜索结果
                allLiterature = []; // 清空合并后的文献列表
                
                // 清空项目文件中的模块1数据
                if (currentProject) {
                    try {
                        const clearData = {
                            search: {
                                results: {} // 清空搜索结果
                            },
                            finalResults: [] // 清空最终结果
                        };
                        await mergeAndSave(currentProject, clearData);
                        console.log('已清空项目中的模块1文献列表');
                    } catch (error) {
                        console.error('清空项目数据失败:', error);
                    }
                }
                
                // 清空显示
                if (finalResultsSection) {
                    finalResultsSection.style.display = 'none';
                }
                if (finalResultsContainer) {
                    finalResultsContainer.innerHTML = '<div class="empty-state"><p>暂无文献</p></div>';
                }
                if (finalCount) {
                    finalCount.textContent = '0';
                }
                
                // 先打开登录/验证窗口
                try {
                    if (window.electronAPI && window.electronAPI.openScholarLogin) {
                        await window.electronAPI.openScholarLogin();
                        console.log('登录/验证完成，开始搜索');
                    }
                } catch (loginError) {
                    console.error('登录/验证失败:', loginError);
                    showToast('登录/验证失败: ' + loginError.message + '，搜索已取消', 'error');
                    return;
                }
                
                // 显示进度条
                searchProgress.style.display = 'block';
                // 不展示分关键词结果
                
                try {
                    // 循环搜索每个关键词
                    let totalFound = 0; // 累计找到的结果数
                    for (let i = 0; i < keywords.length; i++) {
                        const keyword = keywords[i];
                        const currentProgress = ((i) / keywords.length) * 100;
                        updateProgress(currentProgress, `正在搜索: ${keyword} (${i + 1}/${keywords.length})`);
                        
                        // 搜索文献（年份限制在搜索时应用，引用数限制在结果中过滤）
                        const perCount = Number(prefMaxPerKeywordInput.value) || 10;
                        const minYear = Number(prefStartYearInput.value) || null;
                        const minCitations = prefMinCitationsInput.value ? Number(prefMinCitationsInput.value) : null;
                        
                        // 搜索时传递年份参数，让Google Scholar在搜索时就过滤年份
                        let results = await searchGoogleScholar(keyword, perCount, minYear);
                        console.log(`关键词 "${keyword}" 搜索返回 ${results ? results.length : 0} 条结果 (年份限制: ${minYear || '无'})`);
                        
                        // 只过滤引用数（年份已在搜索时过滤）
                        const beforeFilter = results.length;
                        if (minCitations !== null && minCitations > 0) {
                            results = results.filter(item => {
                                if (!item) return false;
                                const c = Number(item.cited || 0);
                                return c >= minCitations;
                            });
                            console.log(`关键词 "${keyword}" 引用数过滤后剩余 ${results.length} 条结果 (过滤前: ${beforeFilter}, 最小引用数: ${minCitations})`);
                        } else {
                            console.log(`关键词 "${keyword}" 未设置引用数限制，保留所有 ${results.length} 条结果`);
                        }
                        
                        searchResults[keyword] = results || [];
                        totalFound += results.length;
                        console.log(`已保存关键词 "${keyword}" 的结果到 searchResults`);
                        
                        // 更新进度：显示已完成的关键词和找到的结果数
                        const completedProgress = ((i + 1) / keywords.length) * 100;
                        const completedCount = i + 1;
                        const resultCount = results.length;
                        updateProgress(
                            completedProgress, 
                            `已完成: ${keyword} ✓ (找到${resultCount}条) | 进度: ${completedCount}/${keywords.length} | 累计: ${totalFound}条`
                        );
                        
                        // 等待一小段时间避免请求过于频繁，同时让用户看到进度提示
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                    
                    // 搜索完成
                    updateProgress(100, `搜索完成！共完成 ${keywords.length} 个关键词，累计找到 ${totalFound} 条结果`);
                    setTimeout(() => {
                        searchProgress.style.display = 'none';
                    }, 10000);
                    
                    // 合并去重并展示
                    console.log('搜索完成，开始合并结果...');
                    console.log(`搜索阶段累计找到: ${totalFound} 条结果`);
                    console.log('searchResults 对象:', searchResults);
                    console.log('searchResults 的键:', Object.keys(searchResults));
                    console.log('每个关键词的结果数量:');
                    let verifyTotal = 0;
                    Object.keys(searchResults).forEach(key => {
                        const count = Array.isArray(searchResults[key]) ? searchResults[key].length : 0;
                        verifyTotal += count;
                        console.log(`  "${key}": ${count}`);
                    });
                    console.log(`验证：searchResults 中总项数: ${verifyTotal}，搜索阶段累计: ${totalFound}`);
                    if (verifyTotal !== totalFound) {
                        console.error(`错误：searchResults 总项数 ${verifyTotal} 与搜索阶段累计 ${totalFound} 不一致！`);
                    }
                    
                    consolidateAllResults();
                    console.log('合并后的 allLiterature:', allLiterature);
                    console.log('allLiterature 长度:', allLiterature.length);
                    
                    // 强制显示结果区域
                    if (finalResultsSection) {
                        finalResultsSection.style.display = 'block';
                        console.log('finalResultsSection 已显示');
                        } else {
                        console.error('finalResultsSection 不存在！');
                        }
                    
                        updateConfirmButton();
                    
                    // 如果结果为空，给用户提示
                    if (allLiterature.length === 0) {
                        console.warn('警告：合并后没有找到任何文献！');
                        showToast('搜索完成，但没有找到符合条件的文献', 'error');
                        } else {
                        console.log(`成功找到 ${allLiterature.length} 篇文献`);
                        // 不自动补充摘要，等待用户点击按钮
                    }
                    
                    // 更新状态为 module1
                    await setStatus('module1');
                    // 持久化搜索结果与总表
                    await autoSaveConfig();
                    
                } catch (error) {
                    console.error('搜索文献失败:', error);
                    searchProgress.style.display = 'none';
                    showToast('搜索文献失败: ' + error.message, 'error');
                }
            });
            
            // 已移除分关键词结果与选择逻辑
            
            // 更新进度条
            function updateProgress(percent, text) {
                searchProgressFill.style.width = `${percent}%`;
                searchProgressText.textContent = text;
            }

            // 参数变更自动保存
            [apiKeyInput, prefKeywordCountInput, prefMaxPerKeywordInput, prefStartYearInput, prefMinCitationsInput].forEach(el => {
                el.addEventListener('change', autoSaveConfig);
                el.addEventListener('blur', autoSaveConfig);
            });

            async function autoSaveConfig() {
                if (!currentProject) return;
                const data = getModule1Patch();
                try {
                    await mergeAndSave(currentProject, data);
                } catch (e) {
                    console.error('自动保存失败', e);
                }
            }

            // 搜索开始前重置步骤状态（允许回滚）
            async function setStatus(status) {
                if (!currentProject) return;
                try {
                    const data = getModule1Patch();
                    data.status = status;
                    await mergeAndSave(currentProject, data);
                } catch(e) {
                    console.error('更新步骤失败', e);
                }
            }
            
            // 使用DeepSeek API提取关键词
            async function extractKeywords(topic, apiKey) {
                const response = await fetch('https://api.deepseek.com/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "deepseek-chat",
                        messages: [
                            {
                                "role": "system",
                                "content": "你是一个学术研究助手。请根据用户提供的研究主题，提取5-8个最相关的英文关键词，用于学术文献搜索。只需要输出关键词，每个关键词一行，不要有其他内容。"
                            },
                            {
                                "role": "user",
                                "content": `请为以下研究主题提取关键词: ${topic}`
                            }
                        ],
                        stream: false
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API请求失败: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                const keywordsText = data.choices[0].message.content;
                return keywordsText.split('\n').filter(keyword => keyword.trim() !== '');
            }
            
            // 搜索Google Scholar（真实实现，通过IPC调用主进程）
            async function searchGoogleScholar(keyword, limit = 3, minYear = null) {
                if (!window.electronAPI || !window.electronAPI.searchGoogleScholar) {
                    throw new Error('Google Scholar搜索功能不可用');
                }
                
                try {
                    // 传递年份参数到IPC调用
                    const result = await window.electronAPI.searchGoogleScholar(keyword, limit, minYear);
                    if (result.success && result.results) {
                        return result.results;
                    } else {
                        throw new Error(result.error || '搜索失败');
                    }
                } catch (error) {
                    console.error('Google Scholar搜索错误:', error);
                    throw error;
                }
            }
            
            // 确认完成：整合并保存，返回主页面，推进步骤
            confirmBtn.addEventListener('click', async function() {
                // 直接以合并去重后的总表为准
                consolidateAllResults();
                    finalResultsSection.style.display = 'block';
                try {
                    const projectName = currentProject;
                    if (!projectName) {
                        showToast('未绑定项目，无法保存', 'error');
                        return;
                    }
                    const data = getModule1Patch();
                    data.status = 'module2';
                    await mergeAndSave(projectName, data);
                    showToast(`文献查询完成，共 ${allLiterature.length} 篇不重复文献，已保存至项目`);
                    // 延迟跳转，让用户看到Toast通知
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 1500);
                } catch (e) {
                    console.error('保存项目失败:', e);
                    showToast('保存项目失败: ' + e.message, 'error');
                }
            });
            
            // 检查两个文献是否重复（简单判断：题目一样就是重复）
            function isDuplicateLiterature(item1, item2) {
                if (!item1 || !item2 || !item1.title || !item2.title) {
                    return false;
                }
                
                // 直接比较标题（忽略大小写和前后空格）
                const title1 = item1.title.toLowerCase().trim();
                const title2 = item2.title.toLowerCase().trim();
                
                // 题目一样就是重复
                return title1 === title2;
            }
            
            // 合并所有关键词结果（不去重，直接合并）
            function consolidateAllResults() {
                const all = [];
                let totalBeforeMerge = 0; // 统计合并前的总数
                
                console.log('开始合并，searchResults keys:', Object.keys(searchResults));
                
                // 遍历所有关键词的结果
                Object.keys(searchResults).forEach((keyword, index) => {
                    const results = searchResults[keyword];
                    const count = Array.isArray(results) ? results.length : 0;
                    totalBeforeMerge += count;
                    console.log(`关键词 "${keyword}" 的结果数量: ${count}`);
                    
                    if (Array.isArray(results)) {
                        let validCount = 0;
                    results.forEach(item => {
                            if (item && item.title) {
                                all.push(item);
                                validCount++;
                            } else {
                                console.warn(`跳过无效项 (关键词: ${keyword}):`, item);
                            }
                        });
                        if (validCount < count) {
                            console.warn(`关键词 "${keyword}" 有 ${count - validCount} 个无效项被跳过`);
                        }
                    } else {
                        console.warn(`关键词 "${keyword}" 的结果不是数组:`, results);
                    }
                });
                
                console.log(`合并后总数: ${all.length} (searchResults 中总项数: ${totalBeforeMerge})`);
                if (all.length !== totalBeforeMerge) {
                    console.warn(`警告：合并时丢失了 ${totalBeforeMerge - all.length} 个结果（可能是无效项）`);
                }
                
                // 去重：基于题目，相同的题目只保留一个
                const unique = [];
                const titleSet = new Set();
                let duplicateCount = 0;
                
                for (let i = 0; i < all.length; i++) {
                    const item = all[i];
                    if (!item || !item.title) continue;
                    
                    // 使用题目作为唯一标识（忽略大小写和前后空格）
                    const titleKey = item.title.toLowerCase().trim();
                    
                    if (!titleSet.has(titleKey)) {
                        titleSet.add(titleKey);
                        unique.push(item);
                    } else {
                        duplicateCount++;
                        console.log(`发现重复文献，已跳过: "${item.title.substring(0, 50)}"`);
                    }
                }
                
                allLiterature = unique;
                console.log(`去重完成，最终文献数量: ${allLiterature.length} (合并前: ${all.length}, 去重: ${duplicateCount} 篇)`);
                
                // 合并后显示所有文献（包括摘要不完整的）
                displayFinalResults();
            }
            
            // 检查摘要是否完整
            function isAbstractComplete(item) {
                if (!item || !item.abstract) return false;
                const abstract = item.abstract.trim();
                if (abstract.length === 0) return false;
                if (abstract.endsWith('...') || abstract.endsWith('…')) return false;
                if (abstract.length < 100) return false;
                return true;
            }
            
            // 显示最终结果（始终显示所有文献，不完整的摘要标记一下）
            function displayFinalResults() {
                console.log('displayFinalResults 被调用，allLiterature.length:', allLiterature.length);
                
                if (!finalResultsContainer) {
                    console.error('finalResultsContainer 不存在');
                    return;
                }
                
                // 显示所有文献（包括摘要不完整的）
                const literatureToShow = allLiterature.filter(item => item && item.title);
                console.log(`显示所有文献数量: ${literatureToShow.length}`);
                
                if (literatureToShow.length === 0) {
                    console.log('结果为空，显示空状态');
                    finalResultsContainer.innerHTML = `
                        <div class="empty-state">
                            <p>未找到文献</p>
                        </div>
                    `;
                    // 更新最终数量显示
                    finalCount.textContent = literatureToShow.length;
                    
                    // 更新补充摘要按钮状态
                    if (typeof updateCompleteAbstractsButton === 'function') {
                        updateCompleteAbstractsButton();
                    }
                    return;
                }
                
                console.log('开始渲染结果列表...');
                finalResultsContainer.innerHTML = '';
                
                literatureToShow.forEach((item, index) => {
                    const resultItem = document.createElement('div');
                    resultItem.className = 'result-item';
                    
                    // 转义HTML特殊字符
                    const escapeHtml = (text) => {
                        if (!text) return '';
                        const div = document.createElement('div');
                        div.textContent = text;
                        return div.innerHTML;
                    };
                    
                    // 检查摘要是否完整，添加标记
                    const isComplete = isAbstractComplete(item);
                    const abstractStatus = isComplete ? '' : '<span style="color: #f59e0b; font-size: 12px; margin-left: 8px;">(摘要待补充)</span>';
                    
                    // 摘要文本，如果没有或为空，显示提示
                    const abstractText = item.abstract && item.abstract.trim() ? item.abstract.trim() : '摘要待补充...';
                    
                    resultItem.innerHTML = `
                        <div class="result-header">
                            <h3>${escapeHtml(item.title)}${abstractStatus}</h3>
                        </div>
                        <div class="result-meta">
                            <span class="authors">${escapeHtml(item.authors || '')}</span> | 
                            <span class="year">${escapeHtml(item.year || '')}</span> | 
                            <span class="source">${escapeHtml(item.source || '')}</span> | 
                            ${item.cited ? `<span class="cited">被引 ${item.cited}</span>` : ''}
                        </div>
                        <div class="result-abstract">
                            <p>${escapeHtml(abstractText)}</p>
                        </div>
                        ${item.url ? `<div class="result-url">
                            <a href="${escapeHtml(item.url)}" target="_blank">查看原文</a>
                        </div>` : ''}
                    `;
                    finalResultsContainer.appendChild(resultItem);
                });
                
                console.log(`已渲染 ${finalResultsContainer.children.length} 个结果项`);
                
                // 更新最终数量显示（显示所有文献的数量）
                finalCount.textContent = literatureToShow.length;
                
                // 更新补充摘要按钮状态
                if (typeof updateCompleteAbstractsButton === 'function') {
                    updateCompleteAbstractsButton();
                }
                
                // 启用确认按钮
                updateConfirmButton();
            }
            
            // 自动补充所有不完整的摘要（通过标题精准搜索）
            async function autoCompleteAllAbstracts() {
                // 检查electronAPI是否可用
                if (!window.electronAPI || !window.electronAPI.searchGoogleScholar) {
                    console.warn('无法搜索文献，electronAPI不可用');
                    showToast('无法补充摘要，electronAPI不可用', 'error');
                    return;
                }
                
                // 找出所有需要补充的摘要（使用isAbstractComplete检查）
                const incompleteItems = allLiterature.map((item, index) => {
                    if (!item || !item.title) return null;
                    // 使用isAbstractComplete函数检查
                    const isIncomplete = !isAbstractComplete(item);
                    // 只处理不完整且有标题的文献
                    return isIncomplete ? { item, index, originalIndex: index } : null;
                }).filter(x => x !== null);
                
                console.log(`需要补充摘要的文献数量: ${incompleteItems.length}`);
                
                if (incompleteItems.length === 0) {
                    console.log('所有摘要都已完整，无需补充');
                    return;
                }
                
                console.log(`发现 ${incompleteItems.length} 篇文献需要补充摘要，开始精准搜索...`);
                
                // 显示进度提示
                updateProgress(0, `正在搜索文献提取摘要: 0/${incompleteItems.length}`);
                searchProgress.style.display = 'block';
                
                try {
                    let successCount = 0; // 成功完成的文献数量
                    
                    // 逐个使用标题精准搜索
                    for (let i = 0; i < incompleteItems.length; i++) {
                        const { item, index, originalIndex } = incompleteItems[i];
                        
                        // 确保使用allLiterature中的原始对象引用
                        const originalItem = allLiterature[originalIndex] || allLiterature.find(lit => lit.title === item.title) || item;
                        
                        // 开始处理当前文献，更新进度（显示正在处理）
                        const currentProgress = (i / incompleteItems.length) * 100;
                        updateProgress(currentProgress, `正在搜索: ${i + 1}/${incompleteItems.length} - ${originalItem.title.substring(0, 30)}...`);
                        
                        try {
                            // 使用标题进行精准搜索（只搜索1条，找到最匹配的）
                            const searchResult = await window.electronAPI.searchGoogleScholar(originalItem.title, 1);
                            
                            if (searchResult.success && searchResult.results && searchResult.results.length > 0) {
                                const foundItem = searchResult.results[0];
                                
                                // 检查找到的文献标题是否匹配（允许一定的容错）
                                const titleMatch = foundItem.title && (
                                    foundItem.title.toLowerCase().includes(originalItem.title.toLowerCase().substring(0, 20)) ||
                                    originalItem.title.toLowerCase().includes(foundItem.title.toLowerCase().substring(0, 20))
                                );
                                
                                if (titleMatch && foundItem.abstract && foundItem.abstract.trim().length > 50) {
                                    // 更新摘要（直接更新allLiterature中的原始对象）
                                    const newAbstract = foundItem.abstract.trim();
                                    originalItem.abstract = newAbstract;
                                    
                                    console.log(`已更新摘要 - 标题: ${originalItem.title.substring(0, 50)}`);
                                    console.log(`摘要长度: ${newAbstract.length}, 是否完整: ${isAbstractComplete(originalItem)}`);
                                    console.log(`allLiterature索引: ${originalIndex}, 对象引用:`, originalItem === allLiterature[originalIndex]);
                                    
                                    // 检查更新后的摘要是否完整
                                    if (isAbstractComplete(originalItem)) {
                                        successCount++; // 成功计数
                                        
                                        // 立即更新显示（每补充完一个就更新显示）
                                        console.log(`调用 displayFinalResults，当前完整文献数应为: ${successCount}`);
                                        // 使用setTimeout确保摘要已更新到allLiterature
                                        setTimeout(() => {
                                            displayFinalResults(); // 显示所有文献，更新补充后的摘要
                                        }, 100);
                                        
                                        // 更新进度：基于实际完成的文献数量
                                        const actualProgress = (successCount / incompleteItems.length) * 100;
                                        updateProgress(actualProgress, `已完成: ${successCount}/${incompleteItems.length} (${originalItem.title.substring(0, 30)}...)`);
                                        
                                        // 显示成功提示
                                        showToast(`已补充摘要: ${originalItem.title.substring(0, 30)}...`, 'success');
                                    } else {
                                        console.warn(`摘要更新后仍然不完整: ${originalItem.title}, 长度: ${newAbstract.length}`);
                                    }
                                } else {
                                    console.warn(`搜索到的文献不匹配或摘要不完整: ${originalItem.title}`);
                                    const actualProgress = (successCount / incompleteItems.length) * 100;
                                    updateProgress(actualProgress, `处理中: ${i + 1}/${incompleteItems.length} (未找到匹配: ${originalItem.title.substring(0, 30)}...)`);
                                }
                            } else {
                                console.warn(`未找到搜索结果: ${originalItem.title}`);
                                const actualProgress = (successCount / incompleteItems.length) * 100;
                                updateProgress(actualProgress, `处理中: ${i + 1}/${incompleteItems.length} (未找到: ${originalItem.title.substring(0, 30)}...)`);
                            }
                            
                            // 避免请求过于频繁，给搜索时间
                            await new Promise(resolve => setTimeout(resolve, 3000));
                            
                        } catch (error) {
                            console.error(`搜索提取摘要失败 (${originalItem.title}):`, error);
                            // 失败时也更新进度，但基于当前处理的索引
                            const actualProgress = (successCount / incompleteItems.length) * 100;
                            updateProgress(actualProgress, `处理中: ${i + 1}/${incompleteItems.length} (失败: ${originalItem.title.substring(0, 30)}...)`);
                            // 继续处理下一个，不中断整个流程
                        }
                    }
                    
                    // 所有摘要补充完成，更新显示（显示所有文献）
                    displayFinalResults();
                    
                    // 自动保存
                    await autoSaveConfig();
                    
                    // 更新最终进度提示（基于实际成功数量）
                    const finalProgress = (successCount / incompleteItems.length) * 100;
                    updateProgress(finalProgress, `摘要补充完成！成功从 ${successCount}/${incompleteItems.length} 篇文献的搜索结果提取摘要`);
                    setTimeout(() => {
                        searchProgress.style.display = 'none';
                    }, 3000);
                    
                    // 更新补充摘要按钮状态
                    if (typeof updateCompleteAbstractsButton === 'function') {
                        updateCompleteAbstractsButton();
                    }
                    
                    console.log(`成功从 ${successCount}/${incompleteItems.length} 篇文献的搜索结果提取摘要`);
                    
                } catch (error) {
                    console.error('自动补充摘要过程出错:', error);
                    searchProgress.style.display = 'none';
                    showToast('自动补充摘要过程中出现错误，部分摘要可能未补充', 'error');
                }
            }
            
            // 补充摘要功能（保留用于兼容，但不再手动调用）
            async function completeAbstract(index) {
                const item = allLiterature[index];
                if (!item || !item.title) {
                    showToast('无法补充摘要：文献信息不完整', 'error');
                    return;
                }
                
                const btn = document.querySelector(`.btn-complete-abstract[data-index="${index}"]`);
                if (btn) {
                    btn.disabled = true;
                    btn.innerHTML = '<span>⏳ 正在补充...</span>';
                }
                
                try {
                    // 检查API Key
                    const apiKey = apiKeyInput.value.trim();
                    if (!apiKey) {
                        showToast('请先输入DeepSeek API Key', 'error');
                        if (btn) {
                            btn.disabled = false;
                            btn.innerHTML = '<span>📝 补充摘要</span>';
                        }
                        return;
                    }
                    
                    // 使用AI根据文献信息生成完整摘要
                    const prompt = `请根据以下文献信息，生成一个完整的学术文献摘要（Abstract）。摘要应该：

文献信息：
- 标题：${item.title || '无'}
- 作者：${item.authors || '无'}
- 年份：${item.year || '无'}
- 来源：${item.source || '无'}
- 现有摘要片段：${item.abstract || '无'}

要求：
1. 如果现有摘要片段存在，请基于它扩展为完整的摘要（200-300字）
2. 如果现有摘要片段不存在或很短，请根据标题和作者信息推断一个合理的摘要（200-300字）
3. 摘要应该用学术语言，符合学术论文的摘要风格
4. 如果文献是英文，摘要用英文；如果是中文，摘要用中文
5. 只输出摘要内容，不要其他说明文字

请直接输出摘要内容：`;

                    const response = await fetch('https://api.deepseek.com/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: "deepseek-chat",
                            messages: [
                                {
                                    "role": "system",
                                    "content": "你是一个专业的学术文献摘要生成助手。请根据文献信息生成准确、完整的学术摘要。"
                                },
                                {
                                    "role": "user",
                                    "content": prompt
                                }
                            ],
                            stream: false
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API请求失败: ${response.status} ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    const content = data.choices[0].message.content.trim();
                    
                    // 更新摘要
                    item.abstract = content;
                    
                    // 更新显示（显示所有文献，更新补充后的摘要）
                    displayFinalResults();
                    
                    // 自动保存
                    await autoSaveConfig();
                    
                    showToast('摘要补充完成');
                    
                } catch (error) {
                    console.error('补充摘要失败:', error);
                    showToast('补充摘要失败: ' + error.message, 'error');
                    if (btn) {
                        btn.disabled = false;
                        btn.innerHTML = '<span>📝 补充摘要</span>';
                    }
                }
            }

            // 一键补充摘要按钮
            if (completeAbstractsBtn) {
                completeAbstractsBtn.addEventListener('click', async function() {
                    if (allLiterature.length === 0) {
                        showToast('没有文献需要补充摘要', 'error');
                        return;
                    }
                    
                    // 检查是否有不完整的摘要
                    const incompleteCount = allLiterature.filter(item => !isAbstractComplete(item)).length;
                    if (incompleteCount === 0) {
                        showToast('所有文献的摘要都已完整', 'success');
                        return;
                    }
                    
                    // 禁用按钮，防止重复点击
                    completeAbstractsBtn.disabled = true;
                    completeAbstractsBtn.textContent = '正在补充摘要...';
                    
                    try {
                        await autoCompleteAllAbstracts();
                    } catch (error) {
                        console.error('补充摘要失败:', error);
                        showToast('补充摘要过程中出现错误', 'error');
                    } finally {
                        // 恢复按钮状态
                        completeAbstractsBtn.disabled = false;
                        updateCompleteAbstractsButton();
                    }
                });
            }
            
            // 更新补充摘要按钮的显示状态
            function updateCompleteAbstractsButton() {
                if (!completeAbstractsBtn) return;
                
                const incompleteCount = allLiterature.filter(item => !isAbstractComplete(item)).length;
                if (incompleteCount > 0) {
                    completeAbstractsBtn.style.display = 'inline-block';
                    completeAbstractsBtn.textContent = `一键补充摘要 (${incompleteCount}篇待补充)`;
                    completeAbstractsBtn.disabled = false;
                } else {
                    completeAbstractsBtn.textContent = '一键补充摘要';
                    completeAbstractsBtn.disabled = false;
                }
            }
            
            // 导出Excel(CSV)
            const exportBtn = document.getElementById('export-excel-btn');
            exportBtn.addEventListener('click', function() {
                if (!allLiterature || allLiterature.length === 0) {
                    showToast('没有可导出的数据', 'error');
                    return;
                }
                const headers = ['Title','Authors','Year','Source','Cited','URL','Abstract'];
                const rows = allLiterature.map(it => [
                    safeCsv(it.title),
                    safeCsv(it.authors),
                    safeCsv(it.year),
                    safeCsv(it.source),
                    safeCsv(it.cited),
                    safeCsv(it.url),
                    safeCsv(it.abstract)
                ].join(','));
                const csv = [headers.join(',')].concat(rows).join('\n');
                downloadText(csv, `literature_${Date.now()}.csv`, 'text/csv;charset=utf-8;');
            });

            function safeCsv(v) {
                const s = (v === undefined || v === null) ? '' : String(v);
                if (/[",\n]/.test(s)) {
                    return '"' + s.replace(/"/g, '""') + '"';
                }
                return s;
            }

            function downloadText(text, filename, mime) {
                const blob = new Blob([text], { type: mime });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            // 更新确认按钮状态（基于总表是否有数据）
            function updateConfirmButton() {
                confirmBtn.disabled = !(allLiterature && allLiterature.length > 0);
            }
            
            // 返回主页面（页面跳转）
            backBtn.addEventListener('click', function() {
                if (confirm('确定要返回主页面吗？未保存的更改将会丢失。')) {
                    window.location.href = 'index.html';
                }
            });
        });
        
        // Electron IPC API
        window.electronAPI = {
            saveProjectData: (projectName, data) => {
                if (window.require) {
                    const { ipcRenderer } = window.require('electron');
                    return ipcRenderer.invoke('save-project-data', projectName, data);
                }
            },
            loadProjectData: (projectName) => {
                if (window.require) {
                    const { ipcRenderer } = window.require('electron');
                    return ipcRenderer.invoke('load-project-data', projectName);
                }
            },
            listProjects: () => {
                if (window.require) {
                    const { ipcRenderer } = window.require('electron');
                    return ipcRenderer.invoke('list-projects');
                }
            },
            getResearchTopic: () => {
                if (window.require) {
                    const { ipcRenderer } = window.require('electron');
                    return ipcRenderer.invoke('get-research-topic');
                }
            },
            getCurrentProject: () => {
                if (window.require) {
                    const { ipcRenderer } = window.require('electron');
                    return ipcRenderer.invoke('get-current-project');
                }
            },
            searchGoogleScholar: (keyword, limit, minYear) => {
                if (window.require) {
                    const { ipcRenderer } = window.require('electron');
                    return ipcRenderer.invoke('search-google-scholar', keyword, limit, minYear);
                }
            },
            openScholarLogin: () => {
                if (window.require) {
                    const { ipcRenderer } = window.require('electron');
                    return ipcRenderer.invoke('open-scholar-login');
                }
            },
            extractAbstractFromUrl: (url) => {
                if (window.require) {
                    const { ipcRenderer } = window.require('electron');
                    return ipcRenderer.invoke('extract-abstract-from-url', url);
                }
            }
        };
    </script>
</body>
</html>